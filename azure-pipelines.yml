# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- none

variables:
  - group: l3a

resources:
  #https://github.com/MicrosoftDocs/azure-devops-docs/blob/main/docs/pipelines/process/resources.md#define-a-webhooks-resource
  webhooks:
    - webhook: settings 
      connection: supernode-webhook

parameters:
- name: environments
  type: object
  default:
    prod:

pool:
  vmImage: ubuntu-latest

stages:
  - stage: echoSettings
    pool: 
      vmImage: ubuntu-latest
    jobs:
      - job: 'echoParams'
        steps:
          - task: Bash@3
            displayName: ''
            inputs:
              targetType: 'inline'
              script: |
                echo "${{ parameters.settings.adoBuildTag }}"
                echo "##vso[build.addbuildtag]${{ parameters.settings.adoBuildTag }}"
          - ${{ each build in parameters.settings.builds }}:
            - task: Bash@3
              displayName: ''
              inputs:
                targetType: 'inline'
                script: |
                  echo "${{ build.aws_role_arn }}"
                  echo "${{ build.ccm_enabled }}"
                  echo "${{ build.client_name }}"
                  echo "${{ build.count_x86 }}"
                  echo "${{ build.kubernetes_version }}"
                  echo "${{ build.metro }}"
                  echo "${{ build.product_version }}"
                  echo "${{ build.single_xnode }}"
                  echo $(TF_VAR_domain_name)
                  echo $(TF_VAR_secret_bucket)
                  #use single quotes with complex objects!
                  echo '${{ convertToJson(build.features) }}'

  - stage: planBuild
    pool: 
      vmImage: ubuntu-latest
    jobs:
      - job: 'aStageMustHaveOneJob'
        steps:
          - task: Bash@3
            displayName: ''
            inputs:
              targetType: 'inline'
              script: |
                echo "a stage must have one job (with no dependencies)"
      - ${{ each build in parameters.settings.builds }}:
        - job: 'planBuild'
          steps:
            - task: TerraformInstaller@0
              displayName: 'Terraform Installer'
              inputs:
                terraformVersion: '1.3.3'
            - task: InstallSSHKey@0
              inputs:
                knownHostsEntry: '|1|EG23y3SuKXlyTqS0XGNoI2m813Y=|2I81dE2GnKqyYBPbLU2eVqCEazk= ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H'
                sshPublicKey: 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC2d/Br/uztS11ATihf9v4VhDJv1oksh/U1XL4BCghJIovplhOg+n5Ls2hay0Tx3hrCNEpwQ4r5cI2vMxv/7+8ki5ha/Zuwte+fv+PwlDvGnVQWjTnzGRgKKNgW3UYkQjWLbZ97lom+cFfSPLKIe3UelAxl2faf9QtASLdpLYMWdwgAB/2MDFQaKkHloN/vukVnQHtPO9b0SpJKELaIvP3gCsJRo2uP8QcnE/NObOp6ZTD1eehlII/H0blp/gbs7MM+gyRNws5PC+9gjQti1Kr6+78/ewJZyNUCb/c7afhMDAkLjEEuqbmXE+Y/xceYEl2E+uejzzewbUrGOFsKw/wLgAEPT57+lKvojwiE0KYvv0xqgSTsQ3wlLZ7FiFGUAiAXsV7rr2VVYuqojFIovDC4Tl3Fm2deuBRuyJc4SwVE0n8+uPLfjrCECOknKx7UFhMdn9LqzkPWDa1aWkvjTcFZ9HTuc8T1+VVHnBQsSW2BXWzV4l+abuznD+dQYMiB4NE='
                sshKeySecureFile: 'sa_id_rsa'
                addEntryToConfig: true
                configHostname: 'github.com'
                configHostAlias: 'github.com'

            - task: DownloadSecureFile@1
              name: gh_secrets
              displayName: 'secrets tfvars'
              inputs:
                secureFile: 'gh_secrets.tfvars'

            - task: AWSShellScript@1
              name: terraformPlanApply
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  echo "status run with additional output"
                  cat additional_outputs.tf.disabled > additional_outputs.tf

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro

                  terraform plan -compact-warnings \
                                 -var-file=./workloads.tfvars \
                                 -var-file=$(gh_secrets.secureFilePath)

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath)

                  rm -rf additional_outputs.tf

                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusBaseline01
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -replace='null_resource.download_defined_secrets_from_s3["kubeconfig"]' \
                                  -target='null_resource.download_defined_secrets_from_s3["kubeconfig"]' \
                                  -replace='null_resource.download_defined_secrets_from_s3["metal_key"]' \
                                  -target='null_resource.download_defined_secrets_from_s3["metal_key"]'

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars'
                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusBaseline02
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars' \
                                  -var-file 'services/02-base-services.tfvars'
                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusConfluent03
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)
                  echo $kubernetes_api_address

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars' \
                                  -var-file 'services/02-base-services.tfvars' \
                                  -var-file 'services/03-confluent-services.tfvars'
                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusObservability04
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)
                  echo $kubernetes_api_address

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars' \
                                  -var-file 'services/02-base-services.tfvars' \
                                  -var-file 'services/03-confluent-services.tfvars' \
                                  -var-file 'services/04-observability-services.tfvars'
                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusOpenmesh
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars' \
                                  -var-file 'services/02-base-services.tfvars' \
                                  -var-file 'services/03-confluent-services.tfvars' \
                                  -var-file 'services/04-observability-services.tfvars' \
                                  -var-file 'services/10-openmesh-services.tfvars'
                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - task: AWSShellScript@1
              name: checkStatusOutput
              inputs:
                awsCredentials: aws-apl
                regionName: ap-southeast-2
                scriptType: inline
                inlineScript: |
                  sudo apt-get install knockd

                  export TF_VAR_auth_token="${{ build.auth_token }}"
                  export TF_VAR_aws_role_arn="${{ build.aws_role_arn }}"
                  export TF_VAR_ccm_enabled="${{ build.ccm_enabled }}"
                  export TF_VAR_client_name="${{ build.client_name }}"
                  export TF_VAR_count_x86="${{ build.count_x86 }}"
                  export TF_VAR_domain_name=$(TF_VAR_domain_name)
                  export TF_VAR_metro="${{ build.metro }}"
                  export TF_VAR_product_version="${{ build.product_version }}"
                  export TF_VAR_kubernetes_version="${{ build.kubernetes_version }}"
                  export TF_VAR_secret_bucket=$(TF_VAR_secret_bucket)
                  export TF_VAR_single_xnode="${{ build.single_xnode }}"
                  export knock_pattern=$(knock_pattern)
                  export knock_pattern="$(knock_pattern)"

                  #use single quotes with complex objects!
                  export features='${{ convertToJson(build.features) }}'
                  jq --argjson x "$features" '{features:$x}' <<< '{}' > features.auto.tfvars.json

                  echo "status run with additional output"
                  cat additional_outputs.tf.disabled > additional_outputs.tf

                  touch kubeconfig
                  export KUBECONFIG=$PWD/kubeconfig
                  terraform init
                  export TF_WORKSPACE=$TF_VAR_client_name-$TF_VAR_product_version-$TF_VAR_metro
                  export TF_VAR_download_defined_secrets_from_s3='{"kubeconfig": {"file_name": "kubeconfig"}, "metal_key": { "file_name" : "metal_key"}}'
                  export kubernetes_api_address=$(terraform output --raw kubernetes_api_address)

                  knock -d 100 $kubernetes_api_address $knock_pattern || echo "knock failed"
                  knock -d 200 $kubernetes_api_address $knock_pattern && echo "knock succeeded"

                  terraform apply -auto-approve -compact-warnings \
                                  -var-file=./workloads.tfvars \
                                  -var-file=$(gh_secrets.secureFilePath) \
                                  -var-file 'services/01-base-services.tfvars' \
                                  -var-file 'services/02-base-services.tfvars' \
                                  -var-file 'services/03-confluent-services.tfvars' \
                                  -var-file 'services/04-observability-services.tfvars' \
                                  -var-file 'services/10-openmesh-services.tfvars'

                  terraform output -json -no-color | jq 'del(."multiarch-k8s")' > terraform.output.json

                failOnStdErr: true
                targetType: inline
                workingDirectory: $(Build.SourcesDirectory)

            - publish: ./terraform.output.json
              artifact: terraformOutputJson

      - job: 'returnBuildJson'
        dependsOn: planBuild
        steps:
          - download: current
            artifact: terraformOutputJson
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.10'
            displayName: 'Use Python 3.10'
          - task: Bash@3
            displayName: ''
            inputs:
              targetType: 'inline'
              script: |
                pip install pyjson requests
          - task: PythonScript@0
            inputs:
              scriptSource: inline
              script: |
                import json, requests, os

                build_id = $(build.buildid)
                deployer_service_url = "$(deployer_service_url)"
                x_deeeplink_team_signature = "$(x_deeeplink_team_signature)"

                #file_path = "./terraform.output.json"
                file_path = "$(Pipeline.Workspace)/terraformOutputJson/terraform.output.json"

                if not os.path.isfile(file_path):
                  raise FileNotFoundError(f"File not found: {file_path}")
                with open(file_path, "r") as file:
                  terraform_output_data = json.load(file)

                stats_url =  terraform_output_data["stats_urls"]["value"][0]
                pythia_url = terraform_output_data["pythia_url"]["value"]
                project_id = terraform_output_data["project_id"]["value"]

                request_headers = {
                  "Content-Type": "application/json",  # Set the content type to JSON
                  "Accept": "*/*",
                  "x-deeeplink-team-signature": x_deeeplink_team_signature,  # Include any authorization token if required
                }

                request_data = {
                  "buildId": str(build_id),
                  "url1": stats_url,
                  "url2": pythia_url
                }

                try:
                  # Make the POST request
                  response = requests.post(deployer_service_url, json=request_data, headers=request_headers)

                  # Check the response status code
                  response.raise_for_status()

                  # If the response is JSON, you can access it like this:
                  json_response = response.json()

                  print("Request was successful.")
                  print("Response:", json_response)

                except requests.exceptions.HTTPError as errh:
                  print(f"HTTP Error: {errh}")
                except requests.exceptions.ConnectionError as errc:
                  print(f"Error Connecting: {errc}")
                except requests.exceptions.Timeout as errt:
                  print(f"Timeout Error: {errt}")
                except requests.exceptions.RequestException as err:
                  print(f"Something went wrong: {err}")
